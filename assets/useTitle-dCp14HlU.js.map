{"version":3,"mappings":"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","names":["getAccount","id","accounts","store","local","getJSON","find","a","info","getAccountByAccessToken","accessToken","getAccountByInstance","instance","instanceURL","standaloneMQ","window","matchMedia","getCurrentAccountID","session","get","matches","setCurrentAccountID","set","getCurrentAccount","__IGNORE_GET_ACCOUNT_ERROR__","currentAccount","account","getCurrentAccountNS","saveAccount","acc","updateAccount","accountInfo","displayName","currentInstance","getCurrentInstance","instances","e","console","getInstanceConfiguration","configuration","maxMediaAttachments","maxTootChars","pleroma","pollLimits","statuses","polls","maxCharactersPerOption","maxExpiration","getCurrentInstanceConfiguration","key","localStorage","getItem","JSON","value","setJSON","warn","sessionStorage","setItem","data","del","DEFAULT_INSTANCE","apis","accountApis","__ACCOUNT_APIS__","currentAccountApi","initClient","test","replace","toLowerCase","url","client","masto","createRestAPIClient","timeout","initInstance","uri","streamingApi","urls","domain","streaming","streamClient","createStreamingAPIClient","implementation","initAccount","vapidKey","mastoAccount","initPreferences","preferences","accountID","authenticated","_b","_c","instanceAccount","_e","isMastodonLinkMaybe","pathname","hash","URL","_moize","moize","mem","fn","opts","maxSize","isDeepEqual","pmem","isPromise","rateLimit","interval","queue","isRunning","executeNext","length","shift","setTimeout","args","callFn","apply","push","throttle","pThrottle","limit","STATUS_ID_REGEXES","getStatusID","path","i","statusMatchID","match","denylistDomains","failedUnfurls","_unfurlMastodonLink","snapStates","snapshot","states","RegExp","unfurledLinks","Promise","resolve","debug","remoteInstanceFetch","theURL","urlAfterHash","urlObj","hostname","masto2","status","mastoSearchFetch","q","type","results","then","_a","theStatuses","handleFulfill","result","selfURL","instance2","saveStatus","reject","handleCatch","finalPromise","unfurlMastodonLink","proxy","appVersion","prevLocation","currentLocation","statusThreadNumber","home","homeNew","homeLast","homeLastFetchTime","notifications","notificationsLast","notificationsNew","notificationsShowNew","notificationsLastFetchTime","reloadStatusPage","reloadGenericAccounts","counter","spoilers","spoilersMedia","scrollPositions","statusQuotes","statusFollowedTags","statusReply","routeNotification","composerState","showCompose","showSettings","showAccount","showAccounts","showDrafts","showMediaModal","showShortcutsSettings","showKeyboardShortcutsHelp","showGenericAccounts","showMediaAlt","showEmbedModal","showReportModal","shortcuts","settings","autoRefresh","shortcutsViewMode","shortcutsColumnsMode","boostsCarousel","contentTranslation","contentTranslationTargetLanguage","contentTranslationHideLanguages","contentTranslationAutoInline","shortcutSettingsCloudImportExport","mediaAltGenerator","composerGIFPicker","cloakMode","states$1","initStates","subscribeKey","v","subscribe","changes","prevValue","join","statusKey","getStatus","statusID","skipThreading","skipUnfurling","override","oldStatus","deepEqual","_pinned","srKey","sKey","threadifyStatus","unfurlStatus","_threadifyStatus","propInstance","api","traverse","index","fetchIndex","inReplyToAccountId","inReplyToId","prevStatus","r","fetchStatus","fauxDiv","content","document","splice","Loader","abrupt","hidden","props","_jsx","class","children","supportsIntlSegmenter","shouldPolyfill","importIntlSegmenter","__vitePreload","n","catch","importCompose","preload","ComposeSuspense","Compose","setCompose","useState","useEffect","component","PHANPY_CLIENT_NAME","CLIENT_NAME","import","useTitle","title","setTitle","hasPaths","Array","isArray","paths","matched","some","p","matchPath","unsub"],"ignoreList":[],"sources":["../../src/utils/store-utils.js","../../src/utils/store.js","../../src/utils/api.js","../../src/utils/isMastodonLinkMaybe.jsx","../../src/utils/mem.js","../../src/utils/pmem.js","../../src/utils/ratelimit.js","../../src/utils/unfurl-link.jsx","../../src/utils/states.js","../../src/components/loader.jsx","../../src/components/compose-suspense.jsx","../../src/utils/useTitle.js"],"sourcesContent":["import store from './store';\n\nexport function getAccount(id) {\n  const accounts = store.local.getJSON('accounts') || [];\n  if (!id) return accounts[0];\n  return accounts.find((a) => a.info.id === id) || accounts[0];\n}\n\nexport function getAccountByAccessToken(accessToken) {\n  const accounts = store.local.getJSON('accounts') || [];\n  return accounts.find((a) => a.accessToken === accessToken);\n}\n\nexport function getAccountByInstance(instance) {\n  const accounts = store.local.getJSON('accounts') || [];\n  return accounts.find((a) => a.instanceURL === instance);\n}\n\nconst standaloneMQ = window.matchMedia('(display-mode: standalone)');\n\nexport function getCurrentAccountID() {\n  try {\n    const id = store.session.get('currentAccount');\n    if (id) return id;\n  } catch (e) {}\n  if (standaloneMQ.matches) {\n    try {\n      const id = store.local.get('currentAccount');\n      if (id) return id;\n    } catch (e) {}\n  }\n  return null;\n}\n\nexport function setCurrentAccountID(id) {\n  try {\n    store.session.set('currentAccount', id);\n  } catch (e) {}\n  if (standaloneMQ.matches) {\n    try {\n      store.local.set('currentAccount', id);\n    } catch (e) {}\n  }\n}\n\nexport function getCurrentAccount() {\n  if (!window.__IGNORE_GET_ACCOUNT_ERROR__) {\n    // Track down getCurrentAccount() calls before account-based states are initialized\n    console.error('getCurrentAccount() called before states are initialized');\n    if (import.meta.env.DEV) console.trace();\n  }\n  const currentAccount = getCurrentAccountID();\n  const account = getAccount(currentAccount);\n  return account;\n}\n\nexport function getCurrentAccountNS() {\n  const account = getCurrentAccount();\n  const {\n    instanceURL,\n    info: { id },\n  } = account;\n  return `${id}@${instanceURL}`;\n}\n\nexport function saveAccount(account) {\n  const accounts = store.local.getJSON('accounts') || [];\n  const acc = accounts.find((a) => a.info.id === account.info.id);\n  if (acc) {\n    acc.info = account.info;\n    acc.instanceURL = account.instanceURL;\n    acc.accessToken = account.accessToken;\n    acc.vapidKey = account.vapidKey;\n  } else {\n    accounts.push(account);\n  }\n  store.local.setJSON('accounts', accounts);\n  setCurrentAccountID(account.info.id);\n}\n\nexport function updateAccount(accountInfo) {\n  // Only update if displayName or avatar or avatar_static is different\n  const accounts = store.local.getJSON('accounts') || [];\n  const acc = accounts.find((a) => a.info.id === accountInfo.id);\n  if (acc) {\n    if (\n      acc.info.displayName !== accountInfo.displayName ||\n      acc.info.avatar !== accountInfo.avatar ||\n      acc.info.avatar_static !== accountInfo.avatar_static\n    ) {\n      acc.info = {\n        ...acc.info,\n        ...accountInfo,\n      };\n      store.local.setJSON('accounts', accounts);\n    }\n  }\n}\n\nlet currentInstance = null;\nexport function getCurrentInstance() {\n  if (currentInstance) return currentInstance;\n  try {\n    const account = getCurrentAccount();\n    const instances = store.local.getJSON('instances');\n    const instance = account.instanceURL.toLowerCase();\n    return (currentInstance = instances[instance]);\n  } catch (e) {\n    console.error(e);\n    // alert(`Failed to load instance configuration. Please try again.\\n\\n${e}`);\n    // Temporary fix for corrupted data\n    // store.local.del('instances');\n    // location.reload();\n    return {};\n  }\n}\n\n// Massage these instance configurations to match the Mastodon API\n// - Pleroma\nfunction getInstanceConfiguration(instance) {\n  const {\n    configuration,\n    maxMediaAttachments,\n    maxTootChars,\n    pleroma,\n    pollLimits,\n  } = instance;\n\n  const statuses = configuration?.statuses || {};\n  if (maxMediaAttachments) {\n    statuses.maxMediaAttachments ??= maxMediaAttachments;\n  }\n  if (maxTootChars) {\n    statuses.maxCharacters ??= maxTootChars;\n  }\n\n  const polls = configuration?.polls || {};\n  if (pollLimits) {\n    polls.maxCharactersPerOption ??= pollLimits.maxOptionChars;\n    polls.maxExpiration ??= pollLimits.maxExpiration;\n    polls.maxOptions ??= pollLimits.maxOptions;\n    polls.minExpiration ??= pollLimits.minExpiration;\n  }\n\n  return {\n    ...configuration,\n    statuses,\n    polls,\n  };\n}\n\nexport function getCurrentInstanceConfiguration() {\n  const instance = getCurrentInstance();\n  return getInstanceConfiguration(instance);\n}\n\nexport function isMediaFirstInstance() {\n  const instance = getCurrentInstance();\n  return /pixelfed/i.test(instance?.version);\n}\n","import { getCurrentAccountNS } from './store-utils';\n\nconst local = {\n  get: (key) => {\n    try {\n      return localStorage.getItem(key);\n    } catch (e) {\n      console.warn(e);\n      return null;\n    }\n  },\n  getJSON: (key) => {\n    try {\n      return JSON.parse(local.get(key));\n    } catch (e) {\n      console.warn(e);\n      return null;\n    }\n  },\n  set: (key, value) => {\n    try {\n      return localStorage.setItem(key, value);\n    } catch (e) {\n      console.warn(e);\n      return null;\n    }\n  },\n  setJSON: (key, value) => {\n    try {\n      return local.set(key, JSON.stringify(value));\n    } catch (e) {\n      console.warn(e);\n      return null;\n    }\n  },\n  del: (key) => {\n    try {\n      return localStorage.removeItem(key);\n    } catch (e) {\n      console.warn(e);\n      return null;\n    }\n  },\n};\n\nconst session = {\n  get: (key) => {\n    try {\n      return sessionStorage.getItem(key);\n    } catch (e) {\n      console.warn(e);\n      return null;\n    }\n  },\n  getJSON: (key) => {\n    try {\n      return JSON.parse(session.get(key));\n    } catch (e) {\n      console.warn(e);\n      return null;\n    }\n  },\n  set: (key, value) => {\n    try {\n      return sessionStorage.setItem(key, value);\n    } catch (e) {\n      console.warn(e);\n      return null;\n    }\n  },\n  setJSON: (key, value) => {\n    try {\n      return session.set(key, JSON.stringify(value));\n    } catch (e) {\n      console.warn(e);\n      return null;\n    }\n  },\n  del: (key) => {\n    try {\n      return sessionStorage.removeItem(key);\n    } catch (e) {\n      console.warn(e);\n      return null;\n    }\n  },\n};\n\n// Store with account namespace (id@domain.tld) <- uses id, not username\nconst account = {\n  get: (key) => {\n    try {\n      return local.getJSON(key)[getCurrentAccountNS()];\n    } catch (e) {\n      console.warn(e);\n      return null;\n    }\n  },\n  set: (key, value) => {\n    try {\n      const data = local.getJSON(key) || {};\n      data[getCurrentAccountNS()] = value;\n      return local.setJSON(key, data);\n    } catch (e) {\n      console.warn(e);\n      return null;\n    }\n  },\n  del: (key) => {\n    try {\n      const data = local.getJSON(key) || {};\n      delete data[getCurrentAccountNS()];\n      return local.setJSON(key, data);\n    } catch (e) {\n      console.warn(e);\n      return null;\n    }\n  },\n};\n\nexport default { local, session, account };\n","import { createRestAPIClient, createStreamingAPIClient } from 'masto';\n\nimport store from './store';\nimport {\n  getAccount,\n  getAccountByAccessToken,\n  getAccountByInstance,\n  getCurrentAccount,\n  saveAccount,\n  setCurrentAccountID,\n} from './store-utils';\n\n// Default *fallback* instance\nconst DEFAULT_INSTANCE = 'mastodon.social';\n\n// Per-instance masto instance\n// Useful when only one account is logged in\n// I'm not sure if I'll ever allow multiple logged-in accounts but oh well...\n// E.g. apis['mastodon.social']\nconst apis = {};\n\n// Per-account masto instance\n// Note: There can be many accounts per instance\n// Useful when multiple accounts are logged in or when certain actions require a specific account\n// Just in case if I need this one day.\n// E.g. accountApis['mastodon.social']['ACCESS_TOKEN']\nconst accountApis = {};\nwindow.__ACCOUNT_APIS__ = accountApis;\n\n// Current account masto instance\nlet currentAccountApi;\n\nexport function initClient({ instance, accessToken }) {\n  if (/^https?:\\/\\//.test(instance)) {\n    instance = instance\n      .replace(/^https?:\\/\\//, '')\n      .replace(/\\/+$/, '')\n      .toLowerCase();\n  }\n  const url = instance ? `https://${instance}` : `https://${DEFAULT_INSTANCE}`;\n\n  const masto = createRestAPIClient({\n    url,\n    accessToken, // Can be null\n    timeout: 30_000, // Unfortunatly this is global instead of per-request\n  });\n\n  const client = {\n    masto,\n    instance,\n    accessToken,\n  };\n  apis[instance] = client;\n  if (!accountApis[instance]) accountApis[instance] = {};\n  if (accessToken) accountApis[instance][accessToken] = client;\n\n  return client;\n}\n\n// Get the instance information\n// The config is needed for composing\nexport async function initInstance(client, instance) {\n  console.log('INIT INSTANCE', client, instance);\n  const { masto, accessToken } = client;\n  // Request v2, fallback to v1 if fail\n  let info;\n  try {\n    info = await masto.v2.instance.fetch();\n  } catch (e) {}\n  if (!info) {\n    try {\n      info = await masto.v1.instance.fetch();\n    } catch (e) {}\n  }\n  if (!info) return;\n  console.log(info);\n  const {\n    // v1\n    uri,\n    urls: { streamingApi } = {},\n    // v2\n    domain,\n    configuration: { urls: { streaming } = {} } = {},\n  } = info;\n  const instances = store.local.getJSON('instances') || {};\n  if (uri || domain) {\n    instances[\n      (domain || uri)\n        .replace(/^https?:\\/\\//, '')\n        .replace(/\\/+$/, '')\n        .toLowerCase()\n    ] = info;\n  }\n  if (instance) {\n    instances[instance.toLowerCase()] = info;\n  }\n  store.local.setJSON('instances', instances);\n  // This is a weird place to put this but here's updating the masto instance with the streaming API URL set in the configuration\n  // Reason: Streaming WebSocket URL may change, unlike the standard API REST URLs\n  const supportsWebSocket = 'WebSocket' in window;\n  if (supportsWebSocket && (streamingApi || streaming)) {\n    console.log('🎏 Streaming API URL:', streaming || streamingApi);\n    // masto.config.props.streamingApiUrl = streaming || streamingApi;\n    // Legacy masto.ws\n    const streamClient = createStreamingAPIClient({\n      streamingApiUrl: streaming || streamingApi,\n      accessToken,\n      implementation: WebSocket,\n    });\n    client.streaming = streamClient;\n    // masto.ws = streamClient;\n    console.log('🎏 Streaming API client:', client);\n  }\n}\n\n// Get the account information and store it\nexport async function initAccount(client, instance, accessToken, vapidKey) {\n  const { masto } = client;\n  const mastoAccount = await masto.v1.accounts.verifyCredentials();\n\n  console.log('CURRENTACCOUNT SET', mastoAccount.id);\n  setCurrentAccountID(mastoAccount.id);\n\n  saveAccount({\n    info: mastoAccount,\n    instanceURL: instance.toLowerCase(),\n    accessToken,\n    vapidKey,\n  });\n}\n\n// Get preferences\nexport async function initPreferences(client) {\n  try {\n    const { masto } = client;\n    const preferences = await masto.v1.preferences.fetch();\n    store.account.set('preferences', preferences);\n  } catch (e) {\n    // silently fail\n    console.error(e);\n  }\n}\n\n// Get the masto instance\n// If accountID is provided, get the masto instance for that account\nexport function api({ instance, accessToken, accountID, account } = {}) {\n  // Always lowercase and trim the instance\n  if (instance) {\n    instance = instance.toLowerCase().trim();\n  }\n\n  // If instance and accessToken are provided, get the masto instance for that account\n  if (instance && accessToken) {\n    const client =\n      accountApis[instance]?.[accessToken] ||\n      initClient({ instance, accessToken });\n    const { masto, streaming } = client;\n    return {\n      masto,\n      streaming,\n      client,\n      authenticated: true,\n      instance,\n    };\n  }\n\n  if (accessToken) {\n    // If only accessToken is provided, get the masto instance for that accessToken\n    console.log('X 1', accountApis);\n    for (const instance in accountApis) {\n      if (accountApis[instance][accessToken]) {\n        console.log('X 2', accountApis, instance, accessToken);\n        const client = accountApis[instance][accessToken];\n        const { masto, streaming } = client;\n        return {\n          masto,\n          streaming,\n          client,\n          authenticated: true,\n          instance,\n        };\n      } else {\n        console.log('X 3', accountApis, instance, accessToken);\n        const account = getAccountByAccessToken(accessToken);\n        if (account) {\n          const accessToken = account.accessToken;\n          const instance = account.instanceURL.toLowerCase().trim();\n          const client = initClient({ instance, accessToken });\n          const { masto, streaming } = client;\n          return {\n            masto,\n            streaming,\n            client,\n            authenticated: true,\n            instance,\n          };\n        } else {\n          throw new Error(`Access token not found`);\n        }\n      }\n    }\n  }\n\n  // If account is provided, get the masto instance for that account\n  if (account || accountID) {\n    account = account || getAccount(accountID);\n    if (account) {\n      const accessToken = account.accessToken;\n      const instance = account.instanceURL.toLowerCase().trim();\n      const client =\n        accountApis[instance]?.[accessToken] ||\n        initClient({ instance, accessToken });\n      const { masto, streaming } = client;\n      return {\n        masto,\n        streaming,\n        client,\n        authenticated: true,\n        instance,\n      };\n    } else {\n      throw new Error(`Account ${accountID} not found`);\n    }\n  }\n\n  const currentAccount = getCurrentAccount();\n\n  // If only instance is provided, get the masto instance for that instance\n  if (instance) {\n    if (currentAccountApi?.instance === instance) {\n      return {\n        masto: currentAccountApi.masto,\n        streaming: currentAccountApi.streaming,\n        client: currentAccountApi,\n        authenticated: true,\n        instance,\n      };\n    }\n\n    if (currentAccount?.instanceURL === instance) {\n      const { accessToken } = currentAccount;\n      currentAccountApi =\n        accountApis[instance]?.[accessToken] ||\n        initClient({ instance, accessToken });\n      return {\n        masto: currentAccountApi.masto,\n        streaming: currentAccountApi.streaming,\n        client: currentAccountApi,\n        authenticated: true,\n        instance,\n      };\n    }\n\n    const instanceAccount = getAccountByInstance(instance);\n    if (instanceAccount) {\n      const accessToken = instanceAccount.accessToken;\n      const client =\n        accountApis[instance]?.[accessToken] ||\n        initClient({ instance, accessToken });\n      const { masto, streaming } = client;\n      return {\n        masto,\n        streaming,\n        client,\n        authenticated: true,\n        instance,\n      };\n    }\n\n    const client = apis[instance] || initClient({ instance });\n    const { masto, streaming, accessToken } = client;\n    return {\n      masto,\n      streaming,\n      client,\n      authenticated: !!accessToken,\n      instance,\n    };\n  }\n\n  // If no instance is provided, get the masto instance for the current account\n  if (currentAccountApi) {\n    return {\n      masto: currentAccountApi.masto,\n      streaming: currentAccountApi.streaming,\n      client: currentAccountApi,\n      authenticated: true,\n      instance: currentAccountApi.instance,\n    };\n  }\n  if (currentAccount) {\n    const { accessToken, instanceURL: instance } = currentAccount;\n    currentAccountApi =\n      accountApis[instance]?.[accessToken] ||\n      initClient({ instance, accessToken });\n    return {\n      masto: currentAccountApi.masto,\n      streaming: currentAccountApi.streaming,\n      client: currentAccountApi,\n      authenticated: true,\n      instance,\n    };\n  }\n\n  // If no instance is provided and no account is logged in, get the masto instance for DEFAULT_INSTANCE\n  const client =\n    apis[DEFAULT_INSTANCE] || initClient({ instance: DEFAULT_INSTANCE });\n  const { masto, streaming } = client;\n  return {\n    masto,\n    streaming,\n    client,\n    authenticated: false,\n    instance: DEFAULT_INSTANCE,\n  };\n}\n\nwindow.__API__ = {\n  currentAccountApi,\n  apis,\n  accountApis,\n};\n","export default function isMastodonLinkMaybe(url) {\n  try {\n    const { pathname, hash } = new URL(url);\n    return (\n      /^\\/.*\\/\\d+$/i.test(pathname) ||\n      /^\\/(@[^/]+|users\\/[^/]+)\\/(statuses|posts)\\/\\w+\\/?$/i.test(pathname) || // GoToSocial, Takahe\n      /^\\/notes\\/[a-z0-9]+$/i.test(pathname) || // Misskey, Firefish\n      /^\\/(notice|objects)\\/[a-z0-9-]+$/i.test(pathname) || // Pleroma\n      /#\\/[^\\/]+\\.[^\\/]+\\/s\\/.+/i.test(hash) // Phanpy 🫣\n    );\n  } catch (e) {\n    return false;\n  }\n}\n","import moize from 'moize';\n\nwindow._moize = moize;\n\nexport default function mem(fn, opts = {}) {\n  return moize(fn, { ...opts, maxSize: 50, isDeepEqual: true });\n}\n","import mem from './mem';\n\nexport default function pmem(fn, opts = {}) {\n  return mem(fn, { isPromise: true, ...opts });\n}\n","// Rate limit repeated function calls and queue them to set interval\nexport default function rateLimit(fn, interval) {\n  let queue = [];\n  let isRunning = false;\n\n  function executeNext() {\n    if (queue.length === 0) {\n      isRunning = false;\n      return;\n    }\n\n    const nextFn = queue.shift();\n    nextFn();\n    setTimeout(executeNext, interval);\n  }\n\n  return function (...args) {\n    const callFn = () => fn.apply(this, args);\n    queue.push(callFn);\n\n    if (!isRunning) {\n      isRunning = true;\n      setTimeout(executeNext, interval);\n    }\n  };\n}\n","import pThrottle from 'p-throttle';\nimport { snapshot } from 'valtio/vanilla';\n\nimport { api } from './api';\nimport states, { saveStatus } from './states';\n\nexport const throttle = pThrottle({\n  limit: 1,\n  interval: 1000,\n});\n\nconst STATUS_ID_REGEXES = [\n  /\\/@[^@\\/]+@?[^\\/]+?\\/(\\d+)$/i, // Mastodon\n  /\\/notice\\/(\\w+)$/i, // Pleroma\n];\nfunction getStatusID(path) {\n  for (let i = 0; i < STATUS_ID_REGEXES.length; i++) {\n    const statusMatchID = path.match(STATUS_ID_REGEXES[i])?.[1];\n    if (statusMatchID) {\n      return statusMatchID;\n    }\n  }\n  return null;\n}\n\nconst denylistDomains = /(twitter|github)\\.com/i;\nconst failedUnfurls = {};\nfunction _unfurlMastodonLink(instance, url) {\n  const snapStates = snapshot(states);\n  if (denylistDomains.test(url)) {\n    return;\n  }\n  if (failedUnfurls[url]) {\n    return;\n  }\n  const instanceRegex = new RegExp(instance + '/');\n  if (instanceRegex.test(snapStates.unfurledLinks[url]?.url)) {\n    return Promise.resolve(snapStates.unfurledLinks[url]);\n  }\n  console.debug('🦦 Unfurling URL', url);\n\n  let remoteInstanceFetch;\n  let theURL = url;\n\n  // https://elk.zone/domain.com/@stest/123 -> https://domain.com/@stest/123\n  if (/\\/\\/elk\\.[^\\/]+\\/[^\\/]+\\.[^\\/]+/i.test(theURL)) {\n    theURL = theURL.replace(/elk\\.[^\\/]+\\//i, '');\n  }\n\n  // https://trunks.social/status/domain.com/@stest/123 -> https://domain.com/@stest/123\n  if (/\\/\\/trunks\\.[^\\/]+\\/status\\/[^\\/]+\\.[^\\/]+/i.test(theURL)) {\n    theURL = theURL.replace(/trunks\\.[^\\/]+\\/status\\//i, '');\n  }\n\n  // https://phanpy.social/#/domain.com/s/123 -> https://domain.com/statuses/123\n  if (/\\/#\\/[^\\/]+\\.[^\\/]+\\/s\\/.+/i.test(theURL)) {\n    const urlAfterHash = theURL.split('/#/')[1];\n    const finalURL = urlAfterHash.replace(/\\/s\\//i, '/@fakeUsername/');\n    theURL = `https://${finalURL}`;\n  }\n\n  let urlObj;\n  try {\n    urlObj = new URL(theURL);\n  } catch (e) {\n    return;\n  }\n  const domain = urlObj.hostname;\n  const path = urlObj.pathname;\n  // Regex /:username/:id, where username = @username or @username@domain, id = post ID\n  let statusMatchID = getStatusID(path);\n\n  if (statusMatchID) {\n    const id = statusMatchID;\n    const { masto } = api({ instance: domain });\n    remoteInstanceFetch = masto.v1.statuses\n      .$select(id)\n      .fetch()\n      .then((status) => {\n        if (status?.id) {\n          return {\n            status,\n            instance: domain,\n          };\n        } else {\n          throw new Error('No results');\n        }\n      });\n  }\n\n  const { masto } = api({ instance });\n  const mastoSearchFetch = masto.v2.search\n    .fetch({\n      q: theURL,\n      type: 'statuses',\n      resolve: true,\n      limit: 1,\n    })\n    .then((results) => {\n      const { statuses } = results;\n      if (statuses.length > 0) {\n        // Filter out statuses that has content that contains the URL, in-case-sensitive\n        const theStatuses = statuses.filter(\n          (status) =>\n            !status.content?.toLowerCase().includes(theURL.toLowerCase()),\n        );\n\n        if (theStatuses.length === 1) {\n          return {\n            status: theStatuses[0],\n            instance,\n          };\n        }\n        // If there are multiple statuses, give up, something is wrong\n      }\n      throw new Error('No results');\n    });\n\n  function handleFulfill(result) {\n    const { status, instance } = result;\n    const { id } = status;\n    const selfURL = `/${instance}/s/${id}`;\n    console.debug('🦦 Unfurled URL', url, id, selfURL);\n    const data = {\n      id,\n      instance,\n      url: selfURL,\n    };\n    states.unfurledLinks[url] = data;\n    saveStatus(status, instance, {\n      skipThreading: true,\n    });\n    return data;\n  }\n  function handleCatch(e) {\n    failedUnfurls[url] = true;\n  }\n\n  if (remoteInstanceFetch) {\n    // return Promise.any([remoteInstanceFetch, mastoSearchFetch])\n    //   .then(handleFulfill)\n    //   .catch(handleCatch);\n    // If mastoSearchFetch is fulfilled within 3s, return it, else return remoteInstanceFetch\n    const finalPromise = Promise.race([\n      mastoSearchFetch,\n      new Promise((resolve, reject) => setTimeout(reject, 3000)),\n    ]).catch(() => {\n      // If remoteInstanceFetch is fullfilled, return it, else return mastoSearchFetch\n      return remoteInstanceFetch.catch(() => mastoSearchFetch);\n    });\n    return finalPromise.then(handleFulfill).catch(handleCatch);\n  } else {\n    return mastoSearchFetch.then(handleFulfill).catch(handleCatch);\n  }\n}\n\nconst unfurlMastodonLink = throttle(_unfurlMastodonLink);\nexport default unfurlMastodonLink;\n","import { deepEqual } from 'fast-equals';\nimport { proxy, subscribe } from 'valtio';\nimport { subscribeKey } from 'valtio/utils';\n\nimport { api } from './api';\nimport isMastodonLinkMaybe from './isMastodonLinkMaybe';\nimport pmem from './pmem';\nimport rateLimit from './ratelimit';\nimport store from './store';\nimport unfurlMastodonLink from './unfurl-link';\n\nconst states = proxy({\n  appVersion: {},\n  // history: [],\n  prevLocation: null,\n  currentLocation: null,\n  statuses: {},\n  statusThreadNumber: {},\n  home: [],\n  // specialHome: [],\n  homeNew: [],\n  homeLast: null, // Last item in 'home' list\n  homeLastFetchTime: null,\n  notifications: [],\n  notificationsLast: null, // Last read notification\n  notificationsNew: [],\n  notificationsShowNew: false,\n  notificationsLastFetchTime: null,\n  reloadStatusPage: 0,\n  reloadGenericAccounts: {\n    id: null,\n    counter: 0,\n  },\n  spoilers: {},\n  spoilersMedia: {},\n  scrollPositions: {},\n  unfurledLinks: {},\n  statusQuotes: {},\n  statusFollowedTags: {},\n  statusReply: {},\n  accounts: {},\n  routeNotification: null,\n  composerState: {},\n  // Modals\n  showCompose: false,\n  showSettings: false,\n  showAccount: false,\n  showAccounts: false,\n  showDrafts: false,\n  showMediaModal: false,\n  showShortcutsSettings: false,\n  showKeyboardShortcutsHelp: false,\n  showGenericAccounts: false,\n  showMediaAlt: false,\n  showEmbedModal: false,\n  showReportModal: false,\n  // Shortcuts\n  shortcuts: [],\n  // Settings\n  settings: {\n    autoRefresh: false,\n    shortcutsViewMode: null,\n    shortcutsColumnsMode: false,\n    boostsCarousel: true,\n    contentTranslation: true,\n    contentTranslationTargetLanguage: null,\n    contentTranslationHideLanguages: [],\n    contentTranslationAutoInline: false,\n    shortcutSettingsCloudImportExport: false,\n    mediaAltGenerator: false,\n    composerGIFPicker: false,\n    cloakMode: false,\n  },\n});\n\nexport default states;\n\nexport function initStates() {\n  // init all account based states\n  // all keys that uses store.account.get() should be initialized here\n  states.notificationsLast = store.account.get('notificationsLast') || null;\n  states.shortcuts = store.account.get('shortcuts') ?? [];\n  states.settings.autoRefresh =\n    store.account.get('settings-autoRefresh') ?? false;\n  states.settings.shortcutsViewMode =\n    store.account.get('settings-shortcutsViewMode') ?? null;\n  if (store.account.get('settings-shortcutsColumnsMode')) {\n    states.settings.shortcutsColumnsMode = true;\n  }\n  states.settings.boostsCarousel =\n    store.account.get('settings-boostsCarousel') ?? true;\n  states.settings.contentTranslation =\n    store.account.get('settings-contentTranslation') ?? true;\n  states.settings.contentTranslationTargetLanguage =\n    store.account.get('settings-contentTranslationTargetLanguage') || null;\n  states.settings.contentTranslationHideLanguages =\n    store.account.get('settings-contentTranslationHideLanguages') || [];\n  states.settings.contentTranslationAutoInline =\n    store.account.get('settings-contentTranslationAutoInline') ?? false;\n  states.settings.shortcutSettingsCloudImportExport =\n    store.account.get('settings-shortcutSettingsCloudImportExport') ?? false;\n  states.settings.mediaAltGenerator =\n    store.account.get('settings-mediaAltGenerator') ?? false;\n  states.settings.composerGIFPicker =\n    store.account.get('settings-composerGIFPicker') ?? false;\n  states.settings.cloakMode = store.account.get('settings-cloakMode') ?? false;\n}\n\nsubscribeKey(states, 'notificationsLast', (v) => {\n  console.log('CHANGE', v);\n  store.account.set('notificationsLast', states.notificationsLast);\n});\nsubscribe(states, (changes) => {\n  console.debug('STATES change', changes);\n  for (const [action, path, value, prevValue] of changes) {\n    if (path.join('.') === 'settings.autoRefresh') {\n      store.account.set('settings-autoRefresh', !!value);\n    }\n    if (path.join('.') === 'settings.boostsCarousel') {\n      store.account.set('settings-boostsCarousel', !!value);\n    }\n    if (path.join('.') === 'settings.shortcutsViewMode') {\n      store.account.set('settings-shortcutsViewMode', value);\n    }\n    if (path.join('.') === 'settings.contentTranslation') {\n      store.account.set('settings-contentTranslation', !!value);\n    }\n    if (path.join('.') === 'settings.contentTranslationAutoInline') {\n      store.account.set('settings-contentTranslationAutoInline', !!value);\n    }\n    if (path.join('.') === 'settings.shortcutSettingsCloudImportExport') {\n      store.account.set('settings-shortcutSettingsCloudImportExport', !!value);\n    }\n    if (path.join('.') === 'settings.contentTranslationTargetLanguage') {\n      console.log('SET', value);\n      store.account.set('settings-contentTranslationTargetLanguage', value);\n    }\n    if (/^settings\\.contentTranslationHideLanguages/i.test(path.join('.'))) {\n      store.account.set(\n        'settings-contentTranslationHideLanguages',\n        states.settings.contentTranslationHideLanguages,\n      );\n    }\n    if (path.join('.') === 'settings.mediaAltGenerator') {\n      store.account.set('settings-mediaAltGenerator', !!value);\n    }\n    if (path.join('.') === 'settings.composerGIFPicker') {\n      store.account.set('settings-composerGIFPicker', !!value);\n    }\n    if (path?.[0] === 'shortcuts') {\n      store.account.set('shortcuts', states.shortcuts);\n    }\n    if (path.join('.') === 'settings.cloakMode') {\n      store.account.set('settings-cloakMode', !!value);\n    }\n  }\n});\n\nexport function hideAllModals() {\n  states.showCompose = false;\n  states.showSettings = false;\n  states.showAccount = false;\n  states.showAccounts = false;\n  states.showDrafts = false;\n  states.showMediaModal = false;\n  states.showShortcutsSettings = false;\n  states.showKeyboardShortcutsHelp = false;\n  states.showGenericAccounts = false;\n  states.showMediaAlt = false;\n  states.showEmbedModal = false;\n}\n\nexport function statusKey(id, instance) {\n  if (!id) return;\n  return instance ? `${instance}/${id}` : id;\n}\n\nexport function getStatus(statusID, instance) {\n  if (instance) {\n    const key = statusKey(statusID, instance);\n    return states.statuses[key];\n  }\n  return states.statuses[statusID];\n}\n\nexport function saveStatus(status, instance, opts) {\n  if (typeof instance === 'object') {\n    opts = instance;\n    instance = null;\n  }\n  const {\n    override = true,\n    skipThreading = false,\n    skipUnfurling = false,\n  } = opts || {};\n  if (!status) return;\n  const oldStatus = getStatus(status.id, instance);\n  if (!override && oldStatus) return;\n  if (deepEqual(status, oldStatus)) return;\n  queueMicrotask(() => {\n    const key = statusKey(status.id, instance);\n    if (oldStatus?._pinned) status._pinned = oldStatus._pinned;\n    // if (oldStatus?._filtered) status._filtered = oldStatus._filtered;\n    states.statuses[key] = status;\n    if (status.reblog?.id) {\n      const srKey = statusKey(status.reblog.id, instance);\n      states.statuses[srKey] = status.reblog;\n    }\n    if (status.quote?.id) {\n      const sKey = statusKey(status.quote.id, instance);\n      states.statuses[sKey] = status.quote;\n      states.statusQuotes[key] = [\n        {\n          id: status.quote.id,\n          instance,\n        },\n      ];\n    }\n  });\n\n  // THREAD TRAVERSER\n  if (!skipThreading) {\n    queueMicrotask(() => {\n      threadifyStatus(status.reblog || status, instance);\n    });\n  }\n\n  // UNFURLER\n  if (!skipUnfurling) {\n    queueMicrotask(() => {\n      unfurlStatus(status.reblog || status, instance);\n    });\n  }\n}\n\nfunction _threadifyStatus(status, propInstance) {\n  const { masto, instance } = api({ instance: propInstance });\n  // Return all statuses in the thread, via inReplyToId, if inReplyToAccountId === account.id\n  let fetchIndex = 0;\n  async function traverse(status, index = 0) {\n    const { inReplyToId, inReplyToAccountId } = status;\n    if (!inReplyToId || inReplyToAccountId !== status.account.id) {\n      return [status];\n    }\n    if (inReplyToId && inReplyToAccountId !== status.account.id) {\n      throw 'Not a thread';\n      // Possibly thread of replies by multiple people?\n    }\n    const key = statusKey(inReplyToId, instance);\n    let prevStatus = states.statuses[key];\n    if (!prevStatus) {\n      if (fetchIndex++ > 3) throw 'Too many fetches for thread'; // Some people revive old threads\n      await new Promise((r) => setTimeout(r, 500 * fetchIndex)); // Be nice to rate limits\n      // prevStatus = await masto.v1.statuses.$.select(inReplyToId).fetch();\n      prevStatus = await fetchStatus(inReplyToId, masto);\n      saveStatus(prevStatus, instance, { skipThreading: true });\n    }\n    // Prepend so that first status in thread will be index 0\n    return [...(await traverse(prevStatus, ++index)), status];\n  }\n  return traverse(status)\n    .then((statuses) => {\n      if (statuses.length > 1) {\n        console.debug('THREAD', statuses);\n        statuses.forEach((status, index) => {\n          const key = statusKey(status.id, instance);\n          states.statusThreadNumber[key] = index + 1;\n        });\n      }\n    })\n    .catch((e) => {\n      console.error(e, status);\n    });\n}\nexport const threadifyStatus = rateLimit(_threadifyStatus, 100);\n\nconst fauxDiv = document.createElement('div');\nexport function unfurlStatus(status, instance) {\n  const { instance: currentInstance } = api();\n  const content = status?.content;\n  const hasLink = /<a/i.test(content);\n  if (hasLink) {\n    const sKey = statusKey(status?.id, instance);\n    fauxDiv.innerHTML = content;\n    const links = fauxDiv.querySelectorAll(\n      'a[href]:not(.u-url):not(.mention):not(.hashtag)',\n    );\n    [...links]\n      .filter((a) => {\n        const url = a.href;\n        const isPostItself = url === status.url || url === status.uri;\n        return !isPostItself && isMastodonLinkMaybe(url);\n      })\n      .forEach((a, i) => {\n        unfurlMastodonLink(currentInstance, a.href).then((result) => {\n          if (!result) return;\n          if (!sKey) return;\n          if (!Array.isArray(states.statusQuotes[sKey])) {\n            states.statusQuotes[sKey] = [];\n          }\n          if (!states.statusQuotes[sKey][i]) {\n            states.statusQuotes[sKey].splice(i, 0, result);\n          }\n        });\n      });\n  }\n}\n\nconst fetchStatus = pmem((statusID, masto) => {\n  return masto.v1.statuses.$select(statusID).fetch();\n});\n","import './loader.css';\n\nfunction Loader({ abrupt, hidden, ...props }) {\n  return (\n    <span\n      {...props}\n      class={`loader-container ${abrupt ? 'abrupt' : ''} ${\n        hidden ? 'hidden' : ''\n      }`}\n    >\n      <span class=\"loader\" />\n    </span>\n  );\n}\n\nexport default Loader;\n","import { shouldPolyfill } from '@formatjs/intl-segmenter/should-polyfill';\nimport { useEffect, useState } from 'preact/hooks';\n\nimport Loader from './loader';\n\nconst supportsIntlSegmenter = !shouldPolyfill();\n\nfunction importIntlSegmenter() {\n  if (!supportsIntlSegmenter) {\n    return import('@formatjs/intl-segmenter/polyfill-force').catch(() => {});\n  }\n}\n\nfunction importCompose() {\n  return import('./compose');\n}\n\nexport async function preload() {\n  try {\n    await importIntlSegmenter();\n    importCompose();\n  } catch (e) {\n    console.error(e);\n  }\n}\n\nexport default function ComposeSuspense(props) {\n  const [Compose, setCompose] = useState(null);\n\n  useEffect(() => {\n    (async () => {\n      try {\n        if (supportsIntlSegmenter) {\n          const component = await importCompose();\n          setCompose(component);\n        } else {\n          await importIntlSegmenter();\n          const component = await importCompose();\n          setCompose(component);\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    })();\n  }, []);\n\n  return Compose?.default ? <Compose.default {...props} /> : <Loader />;\n}\n","import { useLayoutEffect } from 'preact/hooks';\nimport { matchPath } from 'react-router-dom';\nimport { subscribeKey } from 'valtio/utils';\n\nimport states from './states';\n\nconst { PHANPY_CLIENT_NAME: CLIENT_NAME } = import.meta.env;\n\nexport default function useTitle(title, path) {\n  function setTitle() {\n    const { currentLocation } = states;\n    const hasPaths = Array.isArray(path);\n    let paths = hasPaths ? path : [];\n    // Workaround for matchPath not working for optional path segments\n    // https://github.com/remix-run/react-router/discussions/9862\n    if (!hasPaths && /:?\\w+\\?/.test(path)) {\n      paths.push(path.replace(/(:\\w+)\\?/g, '$1'));\n      paths.push(path.replace(/\\/?:\\w+\\?/g, ''));\n    }\n    let matched = false;\n    if (paths.length) {\n      matched = paths.some((p) => matchPath(p, currentLocation));\n    } else if (path) {\n      matched = matchPath(path, currentLocation);\n    }\n    console.debug('setTitle', { title, path, currentLocation, paths, matched });\n    if (matched) {\n      document.title = title ? `${title} / ${CLIENT_NAME}` : CLIENT_NAME;\n    }\n  }\n\n  useLayoutEffect(() => {\n    const unsub = subscribeKey(states, 'currentLocation', setTitle);\n    setTitle();\n    return unsub;\n  }, [title, path]);\n}\n"],"file":"assets/useTitle-dCp14HlU.js"}